// generate_junit_report.mjs
// Ten skrypt wyłącznie parsuje tekstowy plik logu Gatlinga i generuje raport JUnit XML.
// Jest to podejście mniej niezawodne niż parsowanie strukturalnych plików statystyk (.js lub .json).

import { create } from 'xmlbuilder2'; // Wymaga instalacji: npm install xmlbuilder2
import fs from 'fs'; // Moduł do operacji na plikach

/**
 * Parsuje tekstowy plik logu Gatlinga i wyodrębnia zagregowane statystyki.
 * @param {string} logContent - Zawartość tekstowego pliku gatling_output.log.
 * @returns {Object} - Obiekt z sparsowanymi statystykami.
 */
function parseGatlingOutputLog(logContent) {
    const stats = {
        totalRequests: 0,
        okRequests: 0,
        koRequests: 0,
        minResponseTime: 0,
        maxResponseTime: 0,
        meanResponseTime: 0,
        stdDevResponseTime: 0,
        p50ResponseTime: 0,
        p75ResponseTime: 0,
        p95ResponseTime: 0,
        p99ResponseTime: 0,
        meanThroughput: 0,
        simulationTimeSeconds: 0,
        simulationName: "basicSimulation" // Domyślna nazwa, jeśli nie uda się jej wyciągnąć
    };

    // Parsowanie danych z logu tekstowego
    // Te wyrażenia regularne są bardzo wrażliwe na zmiany w formacie logu Gatlinga.

    // Sekcja Requests (Total, OK, KO)
    const requestsGlobalMatch = logContent.match(/> Global\s+\|\s+(\d+)\s+\|\s+(\d+)\s+\|\s+(\d+)/);
    if (requestsGlobalMatch) {
        stats.totalRequests = parseInt(requestsGlobalMatch[1]);
        stats.okRequests = parseInt(requestsGlobalMatch[2]);
        stats.koRequests = parseInt(requestsGlobalMatch[3]);
    }

    // Czas trwania symulacji
    const elapsedMatch = logContent.match(/(\d+)s elapsed/);
    if (elapsedMatch) {
        stats.simulationTimeSeconds = parseInt(elapsedMatch[1]);
    }

    // Nazwa symulacji z logu
    const simulationNameMatch = logContent.match(/Simulation ([\w\d]+) started\.\.\./);
    if (simulationNameMatch && simulationNameMatch[1]) {
        stats.simulationName = simulationNameMatch[1];
    }

    // Global Information
    const globalInfoMatches = logContent.matchAll(
        /(request count|min response time \(ms\)|max response time \(ms\)|mean response time \(ms\)|response time std deviation \(ms\)|response time 50th percentile \(ms\)|response time 75th percentile \(ms\)|response time 95th percentile \(ms\)|response time 99th percentile \(ms\)|mean throughput \(rps\))\s+\|\s+([\d,]+)\s+\|\s+([\d,]+)\s+\|\s+(?:[\d,-]+)/g
    );

    for (const match of globalInfoMatches) {
        const metricName = match[1];
        const value = parseInt(match[2].replace(/,/g, '')); // Wartość dla "Total"
        
        switch (metricName) {
            case 'request count':
                if (stats.totalRequests === 0) stats.totalRequests = value; // Jeśli nie sparsowano wcześniej
                break;
            case 'min response time (ms)':
                stats.minResponseTime = value;
                break;
            case 'max response time (ms)':
                stats.maxResponseTime = value;
                break;
            case 'mean response time (ms)':
                stats.meanResponseTime = value;
                break;
            case 'response time std deviation (ms)':
                stats.stdDevResponseTime = value;
                break;
            case 'response time 50th percentile (ms)':
                stats.p50ResponseTime = value;
                break;
            case 'response time 75th percentile (ms)':
                stats.p75ResponseTime = value;
                break;
            case 'response time 95th percentile (ms)':
                stats.p95ResponseTime = value;
                break;
            case 'response time 99th percentile (ms)':
                stats.p99ResponseTime = value;
                break;
            case 'mean throughput (rps)':
                stats.meanThroughput = value;
                break;
        }
    }
    
    return stats;
}


/**
 * Generuje raport JUnit XML na podstawie sparsowanych statystyk.
 * @param {Object} stats - Sparsowany obiekt statystyk.
 * @returns {string} - Raport JUnit XML jako string.
 */
function generateJUnitReportFromParsedStats(stats) {
    let xml = `<?xml version="1.0" encoding="UTF-8"?>\n`;
    xml += `<testsuites>\n`;
    xml += `  <testsuite name="${stats.simulationName}" tests="${stats.totalRequests}" failures="${stats.koRequests}" errors="0" time="${stats.simulationTimeSeconds.toFixed(3)}" timestamp="${new Date().toISOString().slice(0, 19)}Z">\n`;

    // Właściwości testsuite (ogólne metryki)
    xml += `    <properties>\n`;
    xml += `      <property name="simulation.name" value="${stats.simulationName}"/>\n`;
    xml += `      <property name="simulation.duration.seconds" value="${stats.simulationTimeSeconds.toString()}"/>\n`;
    xml += `      <property name="requests.total" value="${stats.totalRequests.toString()}"/>\n`;
    xml += `      <property name="requests.successful" value="${stats.okRequests.toString()}"/>\n`;
    xml += `      <property name="requests.failed" value="${stats.koRequests.toString()}"/>\n`;
    xml += `      <property name="mean.requests.per.second" value="${stats.meanThroughput.toString()}"/>\n`;
    xml += `      <property name="min.response.time.ms" value="${stats.minResponseTime.toString()}"/>\n`;
    xml += `      <property name="max.response.time.ms" value="${stats.maxResponseTime.toString()}"/>\n`;
    xml += `      <property name="mean.response.time.ms" value="${stats.meanResponseTime.toString()}"/>\n`;
    xml += `      <property name="stddev.response.time.ms" value="${stats.stdDevResponseTime.toString()}"/>\n`;
    xml += `      <property name="p50.response.time.ms" value="${stats.p50ResponseTime.toString()}"/>\n`;
    xml += `      <property name="p75.response.time.ms" value="${stats.p75ResponseTime.toString()}"/>\n`;
    xml += `      <property name="p95.response.time.ms" value="${stats.p95ResponseTime.toString()}"/>\n`;
    xml += `      <property name="p99.response.time.ms" value="${stats.p99ResponseTime.toString()}"/>\n`;
    xml += `    </properties>\n`;

    // TestCase: Podsumowanie sukcesów/porażek
    const summaryTestCaseTime = (stats.meanResponseTime / 1000).toFixed(3); // Używamy średniego czasu odpowiedzi dla tego test case'u

    xml += `    <testcase name="Global Requests Summary" classname="${stats.simulationName}.Summary" time="${summaryTestCaseTime}">\n`;
    if (stats.koRequests > 0) {
        xml += `      <failure message="Performance test failed: ${stats.koRequests} out of ${stats.totalRequests} requests failed.">\n`;
        xml += `        <![CDATA[Total Requests: ${stats.totalRequests}, OK: ${stats.okRequests}, KO: ${stats.koRequests}.\n`;
        xml += `Min Response Time: ${stats.minResponseTime}ms, Max Response Time: ${stats.maxResponseTime}ms, Mean Response Time: ${stats.meanResponseTime}ms.]]>\n`;
        xml += `      </failure>\n`;
    } else {
        xml += `      <system-out><![CDATA[All ${stats.totalRequests} requests completed successfully.]]></system-out>\n`;
    }
    xml += `    </testcase>\n`;

    // Dodatkowe testcase'y dla kluczowych metryk, aby były widoczne jako osobne "testy" w raporcie JUnit
    xml += `    <testcase name="Mean Response Time" classname="${stats.simulationName}.MeanResponseTime" time="${(stats.meanResponseTime / 1000).toFixed(3)}">\n`;
    xml += `      <system-out><![CDATA[Mean response time for all requests: ${stats.meanResponseTime} ms.]]></system-out>\n`;
    xml += `    </testcase>\n`;

    xml += `    <testcase name="Response Time Percentiles" classname="${stats.simulationName}.Percentiles" time="${(stats.p99ResponseTime / 1000).toFixed(3)}">\n`;
    xml += `      <system-out><![CDATA[Response Time Percentiles (ms):\n`;
    xml += `        50th Percentile: ${stats.p50ResponseTime}\n`;
    xml += `        75th Percentile: ${stats.p75ResponseTime}\n`;
    xml += `        95th Percentile: ${stats.p95ResponseTime}\n`;
    xml += `        99th Percentile: ${stats.p99ResponseTime}\n`;
    xml += `      ]]></system-out>\n`;
    xml += `    </testcase>\n`;

    xml += `    <testcase name="Mean Throughput (RPS)" classname="${stats.simulationName}.Throughput" time="${(stats.totalRequests / (stats.meanThroughput || 1) / 1000).toFixed(3)}">\n`;
    xml += `      <system-out><![CDATA[Mean Throughput: ${stats.meanThroughput} requests/second.]]></system-out>\n`;
    xml += `    </testcase>\n`;

    xml += `  </testsuite>\n`;
    xml += `</testsuites>\n`;

    return xml;
}

/**
 * Główna funkcja skryptu do uruchomienia konwersji.
 * Przyjmuje ścieżkę do pliku logu wejściowego i opcjonalnie ścieżkę do pliku wyjściowego XML.
 */
async function main() {
    const args = process.argv.slice(2); // Argumenty wiersza poleceń

    const logFilePath = args[0]; // Pierwszy argument to ścieżka do logu
    const outputXmlPath = args[1] || 'junit_report_from_log.xml'; // Drugi argument lub domyślna nazwa

    if (!logFilePath) {
        console.error('Użycie: node generate_junit_report.mjs <ścieżka_do_gatling_output.log> [ścieżka_do_pliku_wyjściowego.xml]');
        process.exit(1);
    }

    try {
        if (!fs.existsSync(logFilePath)) {
            throw new Error(`Plik logu nie znaleziony: ${logFilePath}`);
        }

        const logContent = fs.readFileSync(logFilePath, 'utf8');
        const parsedStats = parseGatlingOutputLog(logContent);
        const junitXml = generateJUnitReportFromParsedStats(parsedStats);

        fs.writeFileSync(outputXmlPath, junitXml, 'utf8');
        console.log(`Raport JUnit XML został wygenerowany do: ${outputXmlPath}`);

    } catch (error) {
        console.error(`Błąd podczas generowania raportu JUnit XML: ${error.message}`);
        if (error.stack) {
            console.error(error.stack);
        }
        process.exit(1);
    }
}

// Uruchom funkcję główną, gdy skrypt jest uruchamiany bezpośrednio
if (import.meta.url === `file://${process.argv[1]}`) {
    main();
}
