import fs from 'fs';
import path from 'path';
import vm from 'node:vm';

/**
 * Konwertuje plik stats.js Gatling na format JUnit XML zgodny z Azure DevOps
 * @param {string} statsFilePath - Ścieżka do pliku stats.js
 * @param {string} outputXmlPath - Ścieżka do pliku wyjściowego XML
 */
function convertGatlingStatsToJunitXml(statsFilePath, outputXmlPath) {
  try {
    // Wczytaj zawartość pliku stats.js
    let content = fs.readFileSync(statsFilePath, 'utf-8');
    
    // Stwórz kontekst dla wykonania kodu
    const context = {};
    
    // Wykonaj kod w bezpiecznym kontekście
    vm.runInNewContext('var stats = ' + content.split('var stats = ')[1].split('function fillStats')[0] + '; this.stats = stats;', context);
    
    // Teraz mamy obiekt stats w kontekście
    const stats = context.stats;
    
    // Pobierz nazwę symulacji z ścieżki pliku
    const simulationName = path.basename(path.dirname(path.dirname(statsFilePath)));
    
    // Generuj XML w formacie JUnit zgodnym z Azure DevOps
    // Format pliku: TEST-*.xml jest preferowany przez Azure DevOps
    const timestamp = new Date().toISOString().replace(/:/g, '_');
    
    // Początek dokumentu XML
    let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
    
    // Główny element testsuites - zgodny z oczekiwaniami Azure DevOps
    xml += `<testsuites>\n`;
    
    // Dodaj główną testsuite dla całej symulacji
    xml += `  <testsuite name="${simulationName}" tests="${countTests(stats)}" failures="${countFailures(stats)}" errors="0" skipped="0" timestamp="${new Date().toISOString()}" time="${calculateTotalTime(stats)}">\n`;
    
    // Dodaj właściwości jako komentarz dla lepszej czytelności
    xml += '    <!-- Właściwości testu -->\n';
    xml += '    <properties>\n';
    xml += `      <property name="simulation.name" value="${simulationName}" />\n`;
    xml += `      <property name="total.requests" value="${stats.stats.numberOfRequests.total}" />\n`;
    xml += `      <property name="successful.requests" value="${stats.stats.numberOfRequests.ok}" />\n`;
    xml += `      <property name="failed.requests" value="${stats.stats.numberOfRequests.ko}" />\n`;
    xml += `      <property name="mean.response.time" value="${stats.stats.meanResponseTime.total}" />\n`;
    xml += `      <property name="mean.requests.per.second" value="${stats.stats.meanNumberOfRequestsPerSecond.total}" />\n`;
    xml += '    </properties>\n';
    
    // Dodaj testcase dla globalnych statystyk
    xml += addTestCase(stats, simulationName, "Global");
    
    // Dodaj testcase dla każdego żądania
    if (stats.contents) {
      for (const [key, request] of Object.entries(stats.contents)) {
        xml += addTestCase(request, simulationName, "Request");
      }
    }
    
    xml += '  </testsuite>\n';
    xml += '</testsuites>';
    
    // Zapisz XML do pliku z nazwą zgodną z konwencją Azure DevOps (TEST-*.xml)
    const outputFileName = outputXmlPath.endsWith('.xml') 
      ? outputXmlPath.replace(/\.xml$/, `.xml`)
      : `TEST-${simulationName}.xml`;
    
    fs.writeFileSync(outputFileName, xml);
    console.log(`Raport JUnit XML został zapisany do pliku: ${outputFileName}`);
    
  } catch (error) {
    console.error('Wystąpił błąd podczas konwersji:', error);
  }
}

/**
 * Liczy liczbę testów w statystykach
 * @param {Object} stats - Obiekt ze statystykami
 * @returns {number} - Liczba testów
 */
function countTests(stats) {
  let count = 1; // Liczymy główny test
  
  // Dodajemy liczbę żądań
  if (stats.contents) {
    count += Object.keys(stats.contents).length;
  }
  
  return count;
}

/**
 * Liczy liczbę niepowodzeń w statystykach
 * @param {Object} stats - Obiekt ze statystykami
 * @returns {number} - Liczba niepowodzeń
 */
function countFailures(stats) {
  let failures = parseInt(stats.stats.numberOfRequests.ko) > 0 ? 1 : 0;
  
  // Dodajemy niepowodzenia z poszczególnych żądań
  if (stats.contents) {
    for (const request of Object.values(stats.contents)) {
      if (parseInt(request.stats.numberOfRequests.ko) > 0) {
        failures++;
      }
    }
  }
  
  return failures;
}

/**
 * Oblicza całkowity czas testu
 * @param {Object} stats - Obiekt ze statystykami
 * @returns {number} - Całkowity czas w sekundach
 */
function calculateTotalTime(stats) {
  // Jako przybliżenie całkowitego czasu testu używamy średniego czasu odpowiedzi
  // podzielonego przez 1000 (aby uzyskać sekundy)
  return parseFloat(stats.stats.meanResponseTime.total) / 1000;
}

/**
 * Dodaje testcase dla danego żądania
 * @param {Object} request - Obiekt z danymi żądania
 * @param {string} simulationName - Nazwa symulacji
 * @param {string} type - Typ testcase (Global lub Request)
 * @returns {string} - Fragment XML z testcase
 */
function addTestCase(request, simulationName, type) {
  const requestName = request.name || 'Unknown';
  const requestPath = request.path || '';
  const stats = request.stats;
  
  // Określ, czy test zakończył się sukcesem
  const isSuccess = parseInt(stats.numberOfRequests.ko) === 0;
  const testTime = parseFloat(stats.meanResponseTime.total) / 1000; // Konwersja ms na sekundy
  
  // Tworzenie nazwy klasy zgodnej z konwencją Azure DevOps
  const className = `${simulationName}.${type}.${requestPath}`.replace(/\s+/g, '_');
  
  // Tworzenie nazwy testu zgodnej z konwencją Azure DevOps
  const testName = `${requestName}`.replace(/\s+/g, '_');
  
  let xml = `    <testcase classname="${className}" name="${testName}" time="${testTime}">\n`;
  
  // Jeśli są błędy, dodaj element failure
  if (!isSuccess) {
    xml += `      <failure message="Request failed: ${stats.numberOfRequests.ko} out of ${stats.numberOfRequests.total} requests failed" type="RequestFailure">\n`;
    xml += '        <![CDATA[\n';
    xml += `        Request: ${requestName}\n`;
    xml += `        Path: ${requestPath}\n`;
    xml += `        Total: ${stats.numberOfRequests.total}\n`;
    xml += `        OK: ${stats.numberOfRequests.ok}\n`;
    xml += `        KO: ${stats.numberOfRequests.ko}\n`;
    xml += `        Response Time (ms):\n`;
    xml += `          Min: ${stats.minResponseTime.total}\n`;
    xml += `          50th percentile: ${stats.percentiles1.total}\n`;
    xml += `          75th percentile: ${stats.percentiles2.total}\n`;
    xml += `          95th percentile: ${stats.percentiles3.total}\n`;
    xml += `          99th percentile: ${stats.percentiles4.total}\n`;
    xml += `          Max: ${stats.maxResponseTime.total}\n`;
    xml += `          Mean: ${stats.meanResponseTime.total}\n`;
    xml += `          Std Dev: ${stats.standardDeviation.total}\n`;
    xml += '        ]]>\n';
    xml += '      </failure>\n';
  }
  
  // Dodaj system-out z dodatkowymi informacjami
  xml += '      <system-out>\n';
  xml += '        <![CDATA[\n';
  xml += `        Request: ${requestName}\n`;
  xml += `        Path: ${requestPath}\n`;
  xml += `        Total Requests: ${stats.numberOfRequests.total}\n`;
  xml += `        Successful Requests: ${stats.numberOfRequests.ok}\n`;
  xml += `        Failed Requests: ${stats.numberOfRequests.ko}\n`;
  xml += `        Requests Per Second: ${stats.meanNumberOfRequestsPerSecond.total}\n`;
  xml += `        Response Time Statistics (ms):\n`;
  xml += `          Min: ${stats.minResponseTime.total}\n`;
  xml += `          50th percentile (median): ${stats.percentiles1.total}\n`;
  xml += `          75th percentile: ${stats.percentiles2.total}\n`;
  xml += `          95th percentile: ${stats.percentiles3.total}\n`;
  xml += `          99th percentile: ${stats.percentiles4.total}\n`;
  xml += `          Max: ${stats.maxResponseTime.total}\n`;
  xml += `          Mean (average): ${stats.meanResponseTime.total}\n`;
  xml += `          Standard Deviation: ${stats.standardDeviation.total}\n`;
  
  // Dodaj informacje o grupach czasowych
  xml += `        Response Time Groups:\n`;
  xml += `          t < 800 ms: ${stats.group1.count} (${stats.group1.percentage}%)\n`;
  xml += `          800 ms <= t < 1200 ms: ${stats.group2.count} (${stats.group2.percentage}%)\n`;
  xml += `          t >= 1200 ms: ${stats.group3.count} (${stats.group3.percentage}%)\n`;
  xml += `          failed: ${stats.group4.count} (${stats.group4.percentage}%)\n`;
  xml += '        ]]>\n';
  xml += '      </system-out>\n';
  
  xml += '    </testcase>\n';
  
  return xml;
}

/**
 * Główna funkcja programu
 */
function main() {
  const args = process.argv.slice(2);
  
  if (args.length < 1) {
    console.log("Użycie: node gatling_stats_to_junit.mjs <plik_stats.js> [plik_wyjściowy.xml]");
    process.exit(1);
  }
  
  const statsFilePath = args[0];
  const outputXmlPath = args.length > 1 ? args[1] : `TEST-gatling-results.xml`;
  
  if (!fs.existsSync(statsFilePath)) {
    console.error(`Błąd: Plik ${statsFilePath} nie istnieje.`);
    process.exit(1);
  }
  
  convertGatlingStatsToJunitXml(statsFilePath, outputXmlPath);
}

// Uruchomienie programu
main();
