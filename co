src/steps/auth/TS postAuthToken.ts

import { http, StringBody, check, jsonPath } from '@gatling.io/core';
import { HttpReqBuilder } from '@gatling.io/http';
import { User } from '../../helper/Users';
import { loadConfigService } from '../../helper/loadConfig';

export const postAuthToken = (user: User): HttpReqBuilder => {
    const tokenUrl = loadConfigService().auth.tokenUrl; 

    return http('1. POST /token - Pobranie Access Tokena')
        .post(tokenUrl) 
        .header('Content-Type', 'application/x-www-form-urlencoded')
        .body(
            StringBody(
                `client_id=test-b0&grant_type=password&username=${user.username}&password=${user.password}`
            )
        )
        .check(status().is(200))
        .check(
            // Zapisanie access_token do sesji
            jsonPath('$.access_token').saveAs('accessToken') 
        );
};


src/steps/auth/TS postSessionContext.ts

import { http, StringBody, check, jsonPath } from '@gatling.io/core';
import { HttpReqBuilder } from '@gatling.io/http';
import { User } from '../../helper/Users';
import { loadConfigService } from '../../helper/loadConfig';

export const postSessionContext = (user: User): HttpReqBuilder => {
    const sessionUrl = loadConfigService().nma.renesismma.api.authorization.sessioncontext;

    return http('2. POST /sessioncontext - Inicjalizacja Sesji')
        .post(sessionUrl)
        // Użycie tokena z Kroku 1
        .header('Authorization', 'Bearer #{accessToken}') 
        .header('Content-Type', 'application/json')
        .body(StringBody(`{
            "session": "0A0D0S0CE6333328097ED4D2C5A47C1",
            "fingerType": "MOBILE"
        }`))
        .check(status().is(200))
        .check(
            // Zapisanie Identyfikatora Sesji do sesji Gatling
            jsonPath('$.session.id').saveAs('sessionId') 
        );
};


src/steps/hce/TS postVerify.ts


import { http, StringBody, check, jsonPath } from '@gatling.io/core';
import { HttpReqBuilder } from '@gatling.io/http';
import { User } from '../../helper/Users';
import { loadConfigService } from '../../helper/loadConfig';

export const postVerify = (user: User): HttpReqBuilder => {
    const verifyUrl = loadConfigService().hce.api.verifyUrl;

    return http('3. POST /verify - Weryfikacja Transakcji')
        .post(verifyUrl)
        // Użycie tokena z Kroku 1
        .header('Authorization', 'Bearer #{accessToken}') 
        .header('Content-Type', 'application/json')
        .body(StringBody(
            `{
                "locale": "pl",
                "token": "kod128ie",
                "tzone": "string",
                "data": {
                    // Użycie sessionId z Kroku 2
                    "sessionId": "#{sessionId}" 
                },
                "tokenUniqueReferenceId": "${user.verifyRefId}"
            }`
        ))
        .check(status().is(200))
        .check(
            // Weryfikacja logiki biznesowej
            jsonPath('$.status').is('VERIFIED')
        );
};



src/verifyFlow.gatling.ts

import { scenario, export default simulation, rampUsersPerSec, constantUsersPerSec } from '@gatling.io/core';
import { httpProtocol } from './helper/httpProtocol';
import { Users } from './helper/Users';

// Importowanie zadeklarowanych Kroków
import { postAuthToken } from './steps/auth/TS postAuthToken';
import { postSessionContext } from './steps/auth/TS postSessionContext';
import { postVerify } from './steps/hce/TS postVerify';


// Definicja Scenariusza
const verifyFlow = scenario('A: Pełny Przepływ Weryfikacji Transakcji')
    .exec(postAuthToken(Users.First))
    .exec(postSessionContext(Users.First))
    .exec(postVerify(Users.First));


// Definicja Symulacji i Obciążenia
export default simulation((setup) => {
    setup.inject(
        // Faza 1: Narastanie Obciążenia (Ramp-up)
        // Liniowe zwiększanie obciążenia od 5 do 25 użytkowników na sekundę przez 60 sekund
        rampUsersPerSec(5).to(25).during(60),
        
        // Faza 2: Stałe Obciążenie
        // Utrzymanie stałego obciążenia 25 użytkowników na sekundę przez 180 sekund
        constantUsersPerSec(25).during(180) 
    ).protocols(httpProtocol); 
});


Absolutnie tak! Przygotowałem całe zadanie w formacie, który możesz skopiować i wkleić bezpośrednio do Azure DevOps Story lub zadania, gotowe do implementacji.

Zawiera on tytuł, opis, kryteria akceptacji oraz gotowy przewodnik z kodem (w sekcji "Implementacja techniczna").

Zadanie/Story: Implementacja Testu Wydajnościowego dla Krytycznego Przepływu Weryfikacji
Tytuł Story

[Perf] Implementacja Scenariusza Wydajnościowego: Autoryzacja i Weryfikacja Transakcji

Opis / Cel

Celem tego zadania jest stworzenie nowego, kompletnego scenariusza testu wydajnościowego w Gatling/TypeScript, który symuluje krytyczny przepływ weryfikacji transakcji.

Scenariusz musi poprawnie obsłużyć zależności między endpointami, a mianowicie:

Pobranie Tokena Autoryzacyjnego (/token).

Inicjalizacja Kontekstu Sesji (/sessioncontext).

Weryfikacja Transakcji (/verify).

Test ma służyć do pomiaru wydajności w warunkach narastającego obciążenia.

Kryteria Akceptacji (Definition of Done - DoD)

[ ] Zdefiniowano nowy plik scenariusza verifyFlow.gatling.ts.

[ ] Zaimplementowano kroki: postAuthToken.ts, postSessionContext.ts, postVerify.ts i są one poprawnie połączone.

[ ] Token autoryzacyjny (accessToken) jest poprawnie zapisywany i używany w nagłówkach kolejnych zapytań.

[ ] Identyfikator sesji (sessionId) jest poprawnie zapisywany i używany w ciele zapytania /verify.

[ ] Symulacja wykorzystuje strategię Ramp-up i Constant Users (zgodnie z sekcją 4 poniżej).

[ ] Dodano weryfikację kodu statusu 200 i weryfikację logiki biznesowej (np. jsonPath('$.status').is('VERIFIED')) dla krytycznego kroku /verify.

Implementacja Techniczna (Przewodnik Krok po Kroku)
Ścieżka projektu: src/ (analogicznie do kodu na zdjęciach)

1. Krok: Pobranie Tokena Autoryzacyjnego

Plik: src/steps/auth/TS postAuthToken.ts

TypeScript
import { http, StringBody, check, jsonPath } from '@gatling.io/core';
import { HttpReqBuilder } from '@gatling.io/http';
import { User } from '../../helper/Users';
import { loadConfigService } from '../../helper/loadConfig';

export const postAuthToken = (user: User): HttpReqBuilder => {
    const tokenUrl = loadConfigService().auth.tokenUrl; 

    return http('1. POST /token - Pobranie Access Tokena')
        .post(tokenUrl) 
        .header('Content-Type', 'application/x-www-form-urlencoded')
        .body(
            StringBody(
                `client_id=test-b0&grant_type=password&username=${user.username}&password=${user.password}`
            )
        )
        .check(status().is(200))
        .check(
            // Zapisanie access_token do sesji
            jsonPath('$.access_token').saveAs('accessToken') 
        );
};
2. Krok: Kontekst Sesji

Plik: src/steps/auth/TS postSessionContext.ts

TypeScript
import { http, StringBody, check, jsonPath } from '@gatling.io/core';
import { HttpReqBuilder } from '@gatling.io/http';
import { User } from '../../helper/Users';
import { loadConfigService } from '../../helper/loadConfig';

export const postSessionContext = (user: User): HttpReqBuilder => {
    const sessionUrl = loadConfigService().nma.renesismma.api.authorization.sessioncontext;

    return http('2. POST /sessioncontext - Inicjalizacja Sesji')
        .post(sessionUrl)
        // Użycie tokena z Kroku 1
        .header('Authorization', 'Bearer #{accessToken}') 
        .header('Content-Type', 'application/json')
        .body(StringBody(`{
            "session": "0A0D0S0CE6333328097ED4D2C5A47C1",
            "fingerType": "MOBILE"
        }`))
        .check(status().is(200))
        .check(
            // Zapisanie Identyfikatora Sesji do sesji Gatling
            jsonPath('$.session.id').saveAs('sessionId') 
        );
};
3. Krok: Weryfikacja Transakcji

Plik: src/steps/hce/TS postVerify.ts

TypeScript
import { http, StringBody, check, jsonPath } from '@gatling.io/core';
import { HttpReqBuilder } from '@gatling.io/http';
import { User } from '../../helper/Users';
import { loadConfigService } from '../../helper/loadConfig';

export const postVerify = (user: User): HttpReqBuilder => {
    const verifyUrl = loadConfigService().hce.api.verifyUrl;

    return http('3. POST /verify - Weryfikacja Transakcji')
        .post(verifyUrl)
        // Użycie tokena z Kroku 1
        .header('Authorization', 'Bearer #{accessToken}') 
        .header('Content-Type', 'application/json')
        .body(StringBody(
            `{
                "locale": "pl",
                "token": "kod128ie",
                "tzone": "string",
                "data": {
                    // Użycie sessionId z Kroku 2
                    "sessionId": "#{sessionId}" 
                },
                "tokenUniqueReferenceId": "${user.verifyRefId}"
            }`
        ))
        .check(status().is(200))
        .check(
            // Weryfikacja logiki biznesowej
            jsonPath('$.status').is('VERIFIED')
        );
};
4. Krok: Zbudowanie Scenariusza i Symulacji

Plik: src/verifyFlow.gatling.ts

TypeScript
import { scenario, export default simulation, rampUsersPerSec, constantUsersPerSec } from '@gatling.io/core';
import { httpProtocol } from './helper/httpProtocol';
import { Users } from './helper/Users';

// Importowanie zadeklarowanych Kroków
import { postAuthToken } from './steps/auth/TS postAuthToken';
import { postSessionContext } from './steps/auth/TS postSessionContext';
import { postVerify } from './steps/hce/TS postVerify';


// Definicja Scenariusza
const verifyFlow = scenario('A: Pełny Przepływ Weryfikacji Transakcji')
    .exec(postAuthToken(Users.First))
    .exec(postSessionContext(Users.First))
    .exec(postVerify(Users.First));


// Definicja Symulacji i Obciążenia
export default simulation((setup) => {
    setup.inject(
        // Faza 1: Narastanie Obciążenia (Ramp-up)
        // Liniowe zwiększanie obciążenia od 5 do 25 użytkowników na sekundę przez 60 sekund
        rampUsersPerSec(5).to(25).during(60),
        
        // Faza 2: Stałe Obciążenie
        // Utrzymanie stałego obciążenia 25 użytkowników na sekundę przez 180 sekund
        constantUsersPerSec(25).during(180) 
    ).protocols(httpProtocol); 
});
Cele Wydajnościowe (SLA)

Krok	Metryka	Cel SLA
POST /verify	P95 (95. Percentyl)	Czas odpowiedzi ≤250 ms
Cały Scenariusz	Wskaźnik Błędów	≤0.5%
