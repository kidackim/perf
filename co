import fs from 'fs';
import path from 'path';
import { DOMParser } from 'xmldom';

/**
 * Escapuje znaki specjalne HTML, aby zapobiec XSS.
 * Definiujemy ją na zewnątrz, aby była dostępna globalnie w module.
 * @param {string | number | undefined} unsafe - Tekst lub wartość do escapowania.
 * @returns {string} - Escapowany tekst.
 */
function escapeHtml(unsafe) {
  if (typeof unsafe !== 'string') {
    // Jeśli nie jest stringiem (np. liczba), spróbuj przekonwertować lub zwróć pusty string
    unsafe = String(unsafe || '');
  }
  return unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
}


/**
 * Generuje kod HTML raportu.
 * Używa GRAWISÓW (`) do definicji stringu HTML.
 * @param {string} suiteName - Nazwa testsuite
 * @param {number} totalTests - Liczba testów
 * @param {number} failures - Liczba niepowodzeń
 * @param {number} errors - Liczba błędów
 * @param {number} skipped - Liczba pominiętych testów
 * @param {string} timestamp - Znacznik czasu
 * @param {number} time - Czas wykonania
 * @param {Object} properties - Właściwości
 * @param {Array} testcases - Testcases
 * @param {string} xmlContent - Zawartość pliku XML
 * @param {string} chartJsPath - Względna ścieżka do Chart.js (np. 'chart.umd.js')
 * @param {string} reportJsPath - Względna ścieżka do report.js (np. 'report.js')
 * @returns {string} - Kod HTML
 */
function generateHtml(suiteName, totalTests, failures, errors, skipped, timestamp, time, properties, testcases, xmlContent, chartJsPath, reportJsPath) {
  const passed = totalTests - failures - errors - skipped;
  const successRate = totalTests > 0 ? (passed / totalTests * 100).toFixed(2) : '0.00';

  // Przygotuj dane do wykresów - filtrujemy wartości zerowe dla wykresu kołowego
  const passFailData = [
    { label: 'Udane', value: passed, color: '#4CAF50' },
    { label: 'Nieudane', value: failures, color: '#F44336' },
    { label: 'Błędy', value: errors, color: '#FF9800' },
    { label: 'Pominięte', value: skipped, color: '#9E9E9E' }
  ].filter(item => item.value > 0); // Pokaż tylko niezerowe segmenty

  // Przygotuj dane o czasach odpowiedzi - Top 15, bez Summary/Global
  const responseTimeData = testcases
    .filter(tc => !tc.className.includes('Summary') && !tc.className.includes('Global') && tc.time !== undefined)
    .map(tc => ({
      name: tc.name,
      time: tc.time * 1000, // Konwersja na ms
      color: tc.hasFailure ? '#F44336' : '#4CAF50'
    }))
    .sort((a, b) => b.time - a.time) // Sortuj malejąco
    .slice(0, 15); // Pokaż Top 15

  // Znajdź globalny testcase
  const globalTestCase = testcases.find(tc => tc.className.includes('Global'));

  // Przygotuj dane o percentylach (jeśli dostępne)
  let percentileData = [];
  if (globalTestCase && globalTestCase.systemOut) {
    try {
      // Ulepszony regex, bardziej odporny na spacje, szuka "XXth percentile" i liczby po dwukropku
      const percentileRegex = /(\d{1,3}(?:st|nd|rd|th)\s*percentile).*?:\s*?(\d+)/gi;
      let match;
      while ((match = percentileRegex.exec(globalTestCase.systemOut)) !== null) {
        const percentileValueMatch = match[1].match(/\d+/); // Wyciągnij tylko liczbę z "XXth"
        if (percentileValueMatch) {
             const percentileValue = parseInt(percentileValueMatch[0], 10);
             const responseTimeValue = parseInt(match[2], 10);
             if (!isNaN(percentileValue) && !isNaN(responseTimeValue)) {
                  percentileData.push({
                      percentile: percentileValue.toString(), // Zapisz jako string
                      value: responseTimeValue
                  });
             }
        }
      }
      percentileData.sort((a, b) => parseInt(a.percentile, 10) - parseInt(b.percentile, 10));
    } catch (e) {
       console.error("Błąd podczas parsowania percentyli:", e);
       percentileData = []; // Resetuj w razie błędu
    }
  }

  // Przygotuj obiekt z danymi do wstrzyknięcia do HTML dla skryptu report.js
  const reportDataForJs = {
     passFailData: passFailData,
     responseTimeData: responseTimeData,
     percentileData: percentileData
  };

  // *** POCZĄTEK DEFINICJI HTML - UŻYWAMY GRAWISU ` ***
  return `<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Raport testów wydajnościowych - ${escapeHtml(suiteName)}</title>
  <style>
    /* === POCZĄTEK CSS === (bez zmian w stosunku do poprzedniej wersji) */
    :root {
        --primary-color: #2196F3;
        --success-color: #4CAF50;
        --warning-color: #FF9800;
        --error-color: #F44336;
        --text-color: #333;
        --background-color: #f5f5f5;
        --card-background: #fff;
        --border-color: #ddd;
      }
      body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: var(--text-color); background-color: var(--background-color); margin: 0; padding: 20px; }
      .container { max-width: 1200px; margin: 0 auto; }
      header { text-align: center; margin-bottom: 30px; }
      h1, h2, h3 { color: var(--primary-color); }
      .card { background-color: var(--card-background); border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; padding: 20px; overflow: hidden; }
      .summary { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 30px; }
      .summary-item { flex: 1; min-width: 180px; padding: 15px; border-radius: 8px; text-align: center; box-shadow: 0 1px 3px rgba(0,0,0,0.08); color: white; }
      .summary-item h3 { margin-top: 0; margin-bottom: 10px; font-size: 1em; }
      .summary-item p { margin-bottom: 0; font-size: 1.5em; font-weight: bold; }
      .summary-item.success { background-color: var(--success-color); }
      .summary-item.error { background-color: var(--error-color); }
      .summary-item.warning { background-color: var(--warning-color); }
      .summary-item.info { background-color: var(--primary-color); }
      .summary-item.skipped { background-color: #9E9E9E; } /* Dodano styl dla pominiętych */
      .properties-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
      .properties-table th, .properties-table td { padding: 10px 12px; border: 1px solid var(--border-color); text-align: left; word-break: break-word; }
      .properties-table th { background-color: #e9ecef; color: var(--text-color); font-weight: 600; }
      .properties-table tr:nth-child(even) { background-color: rgba(0,0,0,0.02); }
      .properties-table td:first-child { font-weight: 500; width: 30%; }
      .chart-container { display: flex; flex-wrap: wrap; gap: 20px; margin-bottom: 30px; }
      .chart { flex: 1 1 400px; min-width: 300px; height: 350px; background-color: var(--card-background); border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); padding: 20px; position: relative; }
      .chart h3 { text-align: center; margin-top: 0; margin-bottom: 15px; }
      .testcase { margin-bottom: 10px; padding: 0; border-radius: 8px; background-color: var(--card-background); box-shadow: 0 1px 3px rgba(0,0,0,0.08); overflow: hidden; }
      .testcase-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 12px 15px; background-color: #f8f9fa; border-bottom: 1px solid var(--border-color); }
      .testcase.expanded .testcase-header { border-bottom-color: transparent; }
      .testcase-name { font-weight: bold; flex-grow: 1; margin-right: 10px; word-break: break-all; }
      .testcase-time { margin-left: 10px; font-size: 0.9em; color: #6c757d; white-space: nowrap; }
      .testcase-status { padding: 4px 8px; border-radius: 4px; margin-left: 10px; font-size: 0.85em; white-space: nowrap; color: white; }
      .testcase-status.success { background-color: var(--success-color); }
      .testcase-status.failure { background-color: var(--error-color); }
      .testcase-details { margin-top: 0; padding: 15px; background-color: #fff; border-top: 1px solid var(--border-color); display: none; }
      .testcase-details pre { background-color: #e9ecef; padding: 10px; border-radius: 4px; white-space: pre-wrap; word-wrap: break-word; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; font-size: 0.9em; max-height: 300px; overflow-y: auto; margin-top: 5px; margin-bottom: 10px; }
      .testcase-details p { margin-top: 5px; margin-bottom: 5px; }
      .testcase-details strong { color: var(--primary-color); }
      .testcase.expanded .testcase-details { display: block; }
      .toggle-button { background: none; border: 1px solid var(--border-color); border-radius: 50%; cursor: pointer; font-size: 1em; color: var(--primary-color); width: 24px; height: 24px; line-height: 20px; text-align: center; padding: 0; margin-left: 10px; transition: transform 0.2s ease-in-out; }
      .testcase.expanded .toggle-button { transform: rotate(45deg); }
      .search-container { margin-bottom: 20px; } /* Zmieniono na div */
      #searchInput { width: 100%; padding: 10px 15px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 16px; box-sizing: border-box; }
      .tabs { display: flex; margin-bottom: 0; border-bottom: 1px solid var(--border-color); background-color: #e9ecef; border-radius: 4px 4px 0 0; padding-left: 10px; }
      .tab { padding: 12px 20px; cursor: pointer; border: none; border-bottom: 3px solid transparent; margin-right: 5px; color: #495057; font-weight: 500; transition: all 0.2s ease; }
      .tab:hover { color: var(--primary-color); border-bottom-color: rgba(33, 150, 243, 0.5); }
      .tab.active { color: var(--primary-color); border-bottom-color: var(--primary-color); background-color: transparent; }
      .tab-content { display: none; padding-top: 20px; }
      .tab-content.active { display: block; }
      pre[id="raw-xml-pre"] { max-height: 500px; background-color: #282c34; color: #abb2bf; padding: 15px; border-radius: 4px; border: 1px solid var(--border-color); overflow-x: auto; white-space: pre; } /* Dodano białe znaki pre dla XML */
      @media (max-width: 768px) {
        .chart-container { flex-direction: column; }
        .chart { flex-basis: auto; height: 300px; }
        .testcase-header { flex-wrap: wrap; }
        .testcase-name { flex-basis: 100%; margin-bottom: 5px; }
        .testcase-time, .testcase-status, .toggle-button { margin-left: 0; margin-right: 10px; }
      }
    /* === KONIEC CSS === */
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>Raport testów wydajnościowych</h1>
      <h2>${escapeHtml(suiteName)}</h2>
      <p>Data: ${escapeHtml(new Date(timestamp).toLocaleString('pl-PL'))}</p> </header>

    <div class="tabs">
      <div class="tab active" data-tab="summary">Podsumowanie</div>
      <div class="tab" data-tab="details">Szczegóły testów</div>
      <div class="tab" data-tab="charts">Wykresy</div>
      <div class="tab" data-tab="raw">Surowe dane XML</div>
    </div>

    <div id="summary" class="tab-content active">
      <div class="card">
        <h3>Podsumowanie testów</h3>
        <div class="summary">
          <div class="summary-item info">
            <h3>Wszystkie</h3>
            <p>${totalTests}</p>
          </div>
          <div class="summary-item success">
            <h3>Udane</h3>
            <p>${passed}</p>
          </div>
          <div class="summary-item error">
            <h3>Nieudane</h3>
            <p>${failures}</p>
          </div>
          ${errors > 0 ? `<div class="summary-item warning"><h3>Błędy</h3><p>${errors}</p></div>` : ''}
          ${skipped > 0 ? `<div class="summary-item skipped"><h3>Pominięte</h3><p>${skipped}</p></div>` : ''}
          <div class="summary-item warning">
            <h3>Sukces (%)</h3>
            <p>${successRate}%</p>
          </div>
          <div class="summary-item info">
            <h3>Czas (s)</h3>
            <p>${time.toFixed(2)}</p>
          </div>
        </div>
      </div>

      <div class="card">
        <h3>Właściwości testu</h3>
        ${Object.keys(properties).length > 0 ? `
        <table class="properties-table">
          <thead> <tr> <th>Właściwość</th> <th>Wartość</th> </tr> </thead>
          <tbody>
            ${Object.entries(properties).map(([key, value]) => `
              <tr> <td>${escapeHtml(key)}</td> <td>${escapeHtml(value)}</td> </tr>
            `).join('')}
          </tbody>
        </table>
        ` : '<p>Brak zdefiniowanych właściwości.</p>'}
      </div>

      ${globalTestCase ? `
      <div class="card">
        <h3>Globalne statystyki (system-out)</h3>
        <pre>${escapeHtml(globalTestCase.systemOut.trim())}</pre>
      </div>
      ` : ''}
    </div>

    <div id="details" class="tab-content">
      <div class="card search-container"> <input type="text" id="searchInput" placeholder="Filtruj testy po nazwie lub klasie...">
      </div>

      <div class="testcases">
        ${testcases.map((testcase, index) => `
          <div class="testcase" data-name="${escapeHtml(testcase.name)}" data-classname="${escapeHtml(testcase.className)}">
            <div class="testcase-header" onclick="toggleTestCase(${index})">
              <span class="testcase-name">${escapeHtml(testcase.name)}</span>
              <span class="testcase-time">${(testcase.time * 1000).toFixed(0)} ms</span>
              <span class="testcase-status ${testcase.hasFailure ? 'failure' : 'success'}">${testcase.hasFailure ? 'Błąd' : 'OK'}</span>
              <button class="toggle-button" id="toggle-${index}" aria-expanded="false" aria-controls="details-${index}">+</button>
            </div>
            <div class="testcase-details" id="details-${index}">
              <p><strong>Klasa:</strong> ${escapeHtml(testcase.className)}</p>
              <p><strong>Czas:</strong> ${(testcase.time * 1000).toFixed(2)} ms</p>
              ${testcase.hasFailure ? `
                <p><strong>Status:</strong> <span style="color: var(--error-color); font-weight: bold;">Nieudany</span></p>
                <p><strong>Komunikat:</strong> ${escapeHtml(testcase.failureMessage)}</p>
                <p><strong>Typ błędu:</strong> ${escapeHtml(testcase.failureType)}</p>
                ${testcase.failureContent ? `<p><strong>Szczegóły błędu:</strong></p><pre>${escapeHtml(testcase.failureContent.trim())}</pre>` : ''}
              ` : '<p><strong>Status:</strong> <span style="color: var(--success-color); font-weight: bold;">Udany</span></p>'}
              ${testcase.systemOut ? `<p><strong>Log (system-out):</strong></p><pre>${escapeHtml(testcase.systemOut.trim())}</pre>` : ''}
            </div>
          </div>
        `).join('')}
      </div>
    </div>

    <div id="charts" class="tab-content">
      <div class="chart-container">
        <div class="chart">
          <h3>Status testów</h3>
          <canvas id="statusChart"></canvas>
        </div>

        <div class="chart">
          <h3>Czasy odpowiedzi (Top ${responseTimeData.length}, ms)</h3>
          <canvas id="responseTimeChart"></canvas>
        </div>
      </div>

      ${percentileData.length > 0 ? `
      <div class="chart-container">
        <div class="chart" style="flex-basis: 100%; height: 400px;">
          <h3>Percentyle czasów odpowiedzi (ms)</h3>
          <canvas id="percentileChart"></canvas>
        </div>
      </div>
      ` : ''}
       ${percentileData.length === 0 && globalTestCase ? `
         <div class="card"><p>Brak danych percentyli do wyświetlenia na wykresie (sprawdź format w Global/system-out).</p></div>
       ` : ''}
    </div>

    <div id="raw" class="tab-content">
      <div class="card">
        <h3>Surowe dane XML</h3>
        {/* Używamy pre z odpowiednim ID dla stylów i escapujemy XML */}
        <pre id="raw-xml-pre">${escapeHtml(xmlContent)}</pre>
      </div>
    </div>
  </div>

  {/* --- Wstrzykiwanie danych dla JavaScript (MUSI być PRZED ładowaniem report.js) --- */}
  <script>
    // Przekazanie danych z Node.js do globalnego obiektu w przeglądarce
    // Używamy bezpośrednio JSON.stringify tutaj - jest to bezpieczne, bo dane pochodzą z zaufanego źródła (skryptu serwerowego)
    window.reportData = ${JSON.stringify(reportDataForJs)};
  </script>

  {/* --- Ładowanie bibliotek i skryptu raportu --- */}
  {/* Używamy ścieżek przekazanych jako argumenty - domyślnie 'chart.umd.js' i 'report.js' */}
  <script src="${escapeHtml(chartJsPath)}"></script>
  <script src="${escapeHtml(reportJsPath)}"></script>

</body>
</html>`; // *** KONIEC DEFINICJI HTML - UPEWNIJ SIĘ, ŻE TU JEST GRAWIS ` ***
}


/**
 * Konwertuje plik JUnit XML na raport HTML
 * @param {string} xmlFilePath - Ścieżka do pliku XML
 * @param {string} outputHtmlPath - Ścieżka do pliku wyjściowego HTML
 * @param {string} chartJsPath - Względna ścieżka w HTML do pliku Chart.js (domyślnie 'chart.umd.js')
 * @param {string} reportJsPath - Względna ścieżka w HTML do pliku report.js (domyślnie 'report.js')
 */
function convertJUnitXmlToHtml(xmlFilePath, outputHtmlPath, chartJsPath = 'chart.umd.js', reportJsPath = 'report.js') {
  try {
    console.log(`Odczytywanie pliku XML: ${xmlFilePath}`);
    const xmlContent = fs.readFileSync(xmlFilePath, 'utf-8');

    console.log('Parsowanie XML...');
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');

    const errorNode = xmlDoc.getElementsByTagName('parsererror')[0];
    if (errorNode) {
        console.error("Błąd parsowania XML:", errorNode.textContent);
        throw new Error("Nie udało się sparsować pliku XML. Sprawdź jego poprawność.");
    }

    const testsuiteNode = xmlDoc.getElementsByTagName('testsuite')[0];
    if (!testsuiteNode) {
      // Czasami raporty Gatlinga mają <testsuites> jako root
      const testsuitesNode = xmlDoc.getElementsByTagName('testsuites')[0];
      if (testsuitesNode && testsuitesNode.getElementsByTagName('testsuite').length > 0) {
          // Weź pierwszy testsuite z listy
          testsuiteNode = testsuitesNode.getElementsByTagName('testsuite')[0];
          console.log("Znaleziono element <testsuites>, użyto pierwszego <testsuite>.");
      } else {
           throw new Error('Nie znaleziono elementu <testsuite> ani <testsuites> w pliku XML');
      }
    }

    console.log('Pobieranie atrybutów testsuite...');
    const suiteName = testsuiteNode.getAttribute('name') || 'Nieznana symulacja';
    const totalTests = parseInt(testsuiteNode.getAttribute('tests') || '0', 10);
    const failures = parseInt(testsuiteNode.getAttribute('failures') || '0', 10);
    const errors = parseInt(testsuiteNode.getAttribute('errors') || '0', 10);
    const skipped = parseInt(testsuiteNode.getAttribute('skipped') || '0', 10);
    const timestamp = testsuiteNode.getAttribute('timestamp') || new Date().toISOString();
    const time = parseFloat(testsuiteNode.getAttribute('time') || '0');

    console.log(`Suite: ${suiteName}, Tests: ${totalTests}, Failures: ${failures}, Errors: ${errors}, Skipped: ${skipped}, Time: ${time}s`);

    console.log('Pobieranie właściwości...');
    const properties = {};
    const propertyNodes = testsuiteNode.getElementsByTagName('property');
    for (let i = 0; i < propertyNodes.length; i++) {
      const property = propertyNodes[i];
      const name = property.getAttribute('name');
      const value = property.getAttribute('value');
      if (name && value) {
        properties[name] = value;
      }
    }
    console.log(`Znaleziono ${Object.keys(properties).length} właściwości.`);

    console.log('Pobieranie testcase-ów...');
    const testcases = [];
    const testcaseNodes = testsuiteNode.getElementsByTagName('testcase');
    for (let i = 0; i < testcaseNodes.length; i++) {
      const testcase = testcaseNodes[i];
      const className = testcase.getAttribute('classname') || '';
      const name = testcase.getAttribute('name') || 'Nieznany test';
      const tcTime = parseFloat(testcase.getAttribute('time') || '0');

      const failureNodes = testcase.getElementsByTagName('failure');
      const errorNodes = testcase.getElementsByTagName('error'); // Dodano obsługę błędów
      const hasFailure = failureNodes.length > 0 || errorNodes.length > 0;

      let failureMessage = '';
      let failureType = '';
      let failureContent = '';

      if (failureNodes.length > 0) {
        const failure = failureNodes[0];
        failureMessage = failure.getAttribute('message') || '';
        failureType = failure.getAttribute('type') || 'Failure';
        failureContent = failure.textContent || '';
      } else if (errorNodes.length > 0) {
        const error = errorNodes[0];
        failureMessage = error.getAttribute('message') || '';
        failureType = error.getAttribute('type') || 'Error';
        failureContent = error.textContent || '';
      }

      const systemOutNodes = testcase.getElementsByTagName('system-out');
      let systemOut = '';
      if (systemOutNodes.length > 0) {
        systemOut = systemOutNodes[0].textContent || '';
      }

      const systemErrNodes = testcase.getElementsByTagName('system-err'); // Dodano obsługę system-err
      let systemErr = '';
       if (systemErrNodes.length > 0) {
           systemErr = systemErrNodes[0].textContent || '';
           // Dołącz system-err do system-out dla uproszczenia
           if (systemOut) systemOut += "\n--- System Err ---\n" + systemErr;
           else systemOut = "--- System Err ---\n" + systemErr;
       }


      testcases.push({
        className,
        name,
        time: tcTime,
        hasFailure,
        failureMessage,
        failureType,
        failureContent,
        systemOut // Zawiera teraz też systemErr
      });
    }
     console.log(`Znaleziono ${testcases.length} testcase-ów.`);


    console.log('Generowanie HTML...');
    const html = generateHtml(suiteName, totalTests, failures, errors, skipped, timestamp, time, properties, testcases, xmlContent, chartJsPath, reportJsPath);
    // console.log('Wygenerowany początek HTML:', html.substring(0, 500)); // Opcjonalny log do debugowania

    console.log(`Zapisywanie raportu HTML do: ${outputHtmlPath}`);
    // Zapisz HTML do pliku z jawnym kodowaniem UTF-8
    fs.writeFileSync(outputHtmlPath, html, 'utf-8');
    console.log(`Raport HTML został pomyślnie zapisany.`);

  } catch (error) {
    console.error('\n!!! Wystąpił krytyczny błąd podczas konwersji raportu !!!');
    console.error('Błąd:', error.message);
    if (error.stack) {
      console.error('Stos wywołań:', error.stack);
    }
    process.exit(1); // Zakończ z kodem błędu, aby pipeline wiedział o problemie
  }
}


/**
 * Główna funkcja programu
 */
function main() {
  const args = process.argv.slice(2);

  console.log("Uruchomiono skrypt junit_to_html.mjs");
  console.log("Argumenty:", args);

  if (args.length < 1) {
    console.error("Błąd: Niewystarczająca liczba argumentów.");
    console.log("\nUżycie: node junit_to_html.mjs <plik_junit.xml> [plik_wyjściowy.html] [ścieżka_do_chart.js_w_html] [ścieżka_do_report.js_w_html]");
    console.log("Przykład: node junit_to_html.mjs gatling/simulation.log.xml report.html chart.umd.js report.js");
    console.log("  <plik_junit.xml>           : Ścieżka do wejściowego pliku XML.");
    console.log("  [plik_wyjściowy.html]    : Ścieżka do zapisu raportu HTML (domyślnie: nazwa_xml.html).");
    console.log("  [ścieżka_do_chart.js]    : Ścieżka względna użyta w HTML dla Chart.js (domyślnie: chart.umd.js).");
    console.log("  [ścieżka_do_report.js]   : Ścieżka względna użyta w HTML dla report.js (domyślnie: report.js).\n");
    process.exit(1);
  }

  const xmlFilePath = args[0];
  const outputHtmlPath = args.length > 1 && args[1] ? args[1] : xmlFilePath.replace(/\.[^/.]+$/, ".html"); // Lepsze zastępowanie rozszerzenia

  // Ścieżki względne używane wewnątrz generowanego HTML
  const chartJsRelativePath = args.length > 2 && args[2] ? args[2] : 'chart.umd.js';
  const reportJsRelativePath = args.length > 3 && args[3] ? args[3] : 'report.js';

  console.log(`Plik wejściowy XML: ${xmlFilePath}`);
  console.log(`Plik wyjściowy HTML: ${outputHtmlPath}`);
  console.log(`Ścieżka do Chart.js w HTML: ${chartJsRelativePath}`);
  console.log(`Ścieżka do report.js w HTML: ${reportJsRelativePath}`);


  if (!fs.existsSync(xmlFilePath)) {
    console.error(`\n!!! Błąd: Plik wejściowy XML ${xmlFilePath} nie istnieje. !!!`);
    process.exit(1);
  }

  // Sprawdzenie dostępności Chart.js i report.js w node_modules/katalogu projektu
  // To tylko ostrzeżenie, bo ostateczne umieszczenie plików zależy od pipeline
  const chartJsSourcePath = path.resolve('node_modules/chart.js/dist/chart.umd.js');
  if (!fs.existsSync(chartJsSourcePath)) {
     console.warn(`\nOSTRZEŻENIE: Nie znaleziono pliku Chart.js w ${chartJsSourcePath}. Upewnij się, że jest zainstalowany ('npm install chart.js@4.4.3 --save-dev --save-exact') i że pipeline skopiuje go jako '${chartJsRelativePath}' do katalogu z raportem.\n`);
  } else {
      console.log(`Znaleziono plik źródłowy Chart.js: ${chartJsSourcePath}`);
  }

  const reportJsSourcePath = path.resolve('report.js'); // Zakładamy, że report.js jest w tym samym katalogu co skrypt
  if (!fs.existsSync(reportJsSourcePath)) {
       console.warn(`\nOSTRZEŻENIE: Nie znaleziono pliku report.js w ${reportJsSourcePath}. Upewnij się, że istnieje i że pipeline skopiuje go jako '${reportJsRelativePath}' do katalogu z raportem.\n`);
  } else {
       console.log(`Znaleziono plik report.js: ${reportJsSourcePath}`);
  }

  convertJUnitXmlToHtml(xmlFilePath, outputHtmlPath, chartJsRelativePath, reportJsRelativePath);
}

// Uruchomienie programu
main();
