// raport.mjs (główny skrypt sterujący)

import { execSync } from 'child_process'; // Potrzebne do wywołania toHtml.mjs
import { existsSync, readFileSync } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

// Importujemy funkcje do parsowania logu tekstowego i generowania raportu XML
import { parseGatlingOutputLog, generateJUnitReportFromTextLog } from './generate_junit_report.mjs';

async function main() {
    const _filename = fileURLToPath(import.meta.url);
    const _dirname = dirname(_filename);

    console.log(`Katalog roboczy skryptu: ${process.cwd()}`);
    console.log(`Katalog skryptu: ${_dirname}`);

    // Ścieżka do pliku logu Gatlinga
    const LOG_FILE_PATH = path.join(process.cwd(), 'gatling_output.log'); // Domyślna nazwa i lokalizacja
    const XML_OUTPUT_NAME = 'junit_report_from_log.xml';
    const XML_OUTPUT_PATH = path.join(process.cwd(), XML_OUTPUT_NAME);
    
    // Nazwa katalogu docelowego dla raportów Gatlinga (jeśli toHtml.mjs tam coś zapisuje)
    // Na podstawie Twojego logu: target/gatling
    const resolvedTargetDirectory = path.join(process.cwd(), 'target', 'gatling'); 

    // Nazwa pliku HTML, którą generuje toHtml.mjs (zakładana, na podstawie Twoich poprzednich zrzutów)
    const HTML_OUTPUT_NAME = 'index.html'; // Często Gatling generuje index.html jako główny raport
    const HTML_OUTPUT_PATH = path.join(resolvedTargetDirectory, HTML_OUTPUT_NAME);


    try {
        if (!existsSync(LOG_FILE_PATH)) {
            console.error(`Błąd: Plik logu Gatlinga "${LOG_FILE_PATH}" nie istnieje. Upewnij się, że plik jest obecny.`);
            throw new Error(`Plik logu Gatlinga nie znaleziony: ${LOG_FILE_PATH}`);
        }
        console.log(`Znaleziono plik logu Gatlinga: ${LOG_FILE_PATH}`);

        // Wczytujemy zawartość pliku logu
        const logContent = readFileSync(LOG_FILE_PATH, 'utf8');

        // Parsujemy log i generujemy raport XML
        const stats = parseGatlingOutputLog(logContent);
        const junitXml = generateJUnitReportFromTextLog(stats);

        // Zapisujemy raport XML do pliku
        fs.writeFileSync(XML_OUTPUT_PATH, junitXml, 'utf8');
        console.log(`Raport JUnit XML został wygenerowany do: ${XML_OUTPUT_PATH}`);

        // --- Logika generowania HTML (z zachowaniem wywołania do toHtml.mjs) ---
        console.log(`Generowanie raportu HTML do: ${HTML_OUTPUT_PATH}`);
        
        // Upewnij się, że katalog docelowy dla HTML istnieje, jeśli toHtml.mjs go wymaga
        if (!existsSync(resolvedTargetDirectory)) {
            fs.mkdirSync(resolvedTargetDirectory, { recursive: true });
            console.log(`Utworzono katalog docelowy HTML: ${resolvedTargetDirectory}`);
        }

        // Wywołujemy hipotetyczny skrypt toHtml.mjs
        // Zakładamy, że toHtml.mjs przyjmuje ścieżkę do pliku XML i ścieżkę wyjściową HTML
        // Jeśli toHtml.mjs ma inną sygnaturę, należy ją dostosować.
        // Pamiętaj, że toHtml.mjs musi istnieć i być funkcjonalne.
        try {
            execSync(`node toHtml.mjs "${XML_OUTPUT_PATH}" "${HTML_OUTPUT_PATH}"`, { stdio: 'inherit' });
            console.log(`Wywołano toHtml.mjs do wygenerowania raportu HTML.`);
        } catch (htmlError) {
            console.error(`Błąd podczas wywoływania toHtml.mjs: ${htmlError.message}`);
            // Nie rzucamy tutaj błędu, jeśli generowanie HTML nie jest krytyczne dla ogólnego sukcesu.
            // Możesz zmienić to zachowanie, jeśli generowanie HTML jest obowiązkowe.
        }

        if (existsSync(HTML_OUTPUT_PATH)) {
            console.log(`Raport HTML został wygenerowany: ${HTML_OUTPUT_PATH}`);
        } else {
            console.warn(`Ostrzeżenie: Plik HTML "${HTML_OUTPUT_PATH}" nie został znaleziony po próbie generowania.`);
        }
        // --- Koniec logiki generowania HTML ---


        console.log(`Proces zakończony pomyślnie. Wyniki w katalogu: ${process.cwd()}`);

    } catch (error) {
        console.error(`Wystąpił błąd podczas wykonywania skryptu głównego: ${error.message}`);
        if (error.stack) {
            console.error(error.stack);
        }
        process.exit(1);
    }
}

main();
