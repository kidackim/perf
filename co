import fs from 'fs';
import path from 'path';
import archiver from 'archiver';

const sourceDir = 'target';
const outputDir = process.cwd(); 
const outputFileName = `archive.zip`;
const outputFilePath = path.join(outputDir, outputFileName);

async function createZipArchive(source, output) {
    const sourcePath = path.join(outputDir, source);
    if (!fs.existsSync(sourcePath)) {
        console.error(`❌ Error: Source directory "${sourcePath}" does not exist. Archiving failed.`);
        return false;
    }

    console.log(`⏳ Starting to archive directory "${source}"...`);
    
    if (fs.existsSync(output)) {
        try {
            fs.unlinkSync(output);
            console.log(`⚠️ Removed existing file "${output}".`);
        } catch (error) {
            console.error(`❌ Error deleting existing file: ${error.message}`);
            return false;
        }
    }

    const outputStream = fs.createWriteStream(output);
    const archive = archiver('zip', {
        zlib: { level: 9 }
    });

    const promise = new Promise((resolve, reject) => {
        outputStream.on('close', () => {
            console.log(`✅ ZIP archive created: ${archive.pointer()} bytes.`);
            console.log(`   File: ${output}`);
            resolve();
        });

        archive.on('warning', (err) => {
            if (err.code === 'ENOENT') {
                console.warn(`⚠️ Archiver warning: ${err.message}`);
            } else {
                reject(new Error(`Archiver error: ${err.message}`));
            }
        });

        archive.on('error', (err) => {
            reject(new Error(`Critical archiver error: ${err.message}`));
        });

        outputStream.on('error', (err) => {
            reject(new Error(`Output stream error: ${err.message}`));
        });

        archive.pipe(outputStream);
        
        archive.directory(sourcePath, source);
        
        archive.finalize();
    });

    try {
        await promise;
        return true;
    } catch (error) {
        console.error(`❌ An error occurred while creating the archive: ${error.message}`);
        if (fs.existsSync(output)) {
            fs.unlinkSync(output);
            console.log(`   Deleted partially created file: ${output}`);
        }
        return false;
    }
}

(async () => {
    const success = await createZipArchive(sourceDir, outputFilePath);
    if (!success) {
        process.exit(1);
    }
})();
