---
- name: Load, Run, and Clean Docker image
  hosts: all
  gather_facts: false # Ustaw na true, jeśli potrzebujesz ansible_facts.distribution do wyboru podman/docker
  become: true
  become_user: root
  become_method: sudo

  vars:
    base_docker_path: "/app/docker/images" # Ścieżka bazowa do folderów z obrazami
    # Zmienne przekazywane jako extra-vars z Azure DevOps
    # build_id_from_pipeline
    # TOKEN_PASSWORD
    # GATLING_USERS
    # SIMULATION_NAME
    # image_to_run_name

    # Odczytujemy zmienne z extra-vars
    container_env_TOKEN_PASSWORD: "{{ TOKEN_PASSWORD }}"
    container_env_GATLING_USERS: "{{ GATLING_USERS }}"
    container_env_SIMULATION_NAME: "{{ SIMULATION_NAME }}"

    # Dynamiczne nazwy, które mogą być luźne lub w folderze
    image_name_prefix: "skopeoCopy-gatling-test-" # Potwierdzamy myślnik zgodnie z 'ls'
    current_image_full_folder_name_pattern: "{{ image_name_prefix }}{{ build_id_from_pipeline }}*" # Szukamy folderu z ID i dowolnym sufiksem
    current_image_tar_file_name: "gatling-test-{{ build_id_from_pipeline }}.tar" # Nazwa pliku tar

    # Zmienna do przechowywania ostatecznej ścieżki do pliku tar
    final_tar_path: ""

  tasks:
    - name: Set podman/docker command
      ansible.builtin.set_fact:
        docker_cmd: "podman" # Lub "docker"
    - name: Debug docker_cmd
      ansible.builtin.debug:
        msg: "Using command: {{ docker_cmd }}"
      tags: [ 'debug' ]

    - name: Verify current user and groups
      ansible.builtin.shell: |
        echo "Current user: $(whoami)"
        echo "User ID info: $(id)"
        echo "User groups: $(groups)"
      register: user_info
      changed_when: false
      tags: [ 'debug' ]
    - name: Display current user and groups info
      ansible.builtin.debug:
        msg: |
          "Current user: {{ user_info.stdout_lines[0] | default('N/A') }}"
          "User ID info: {{ user_info.stdout_lines[1] | default('N/A') }}"
          "User groups: {{ user_info.stdout_lines[2] | default('N/A') }}"
      tags: [ 'debug' ]

    # --- KROK 1: Znajdź plik .tar (elastyczna logika) ---

    - name: Check if .tar file exists directly in {{ base_docker_path }}
      ansible.builtin.stat:
        path: "{{ base_docker_path }}/{{ current_image_tar_file_name }}"
      register: tar_file_status_direct

    - name: Set final_tar_path if .tar file found directly
      ansible.builtin.set_fact:
        final_tar_path: "{{ base_docker_path }}/{{ current_image_tar_file_name }}"
      when: tar_file_status_direct.stat.exists

    - name: Debug: Tar file found directly?
      ansible.builtin.debug:
        msg: "Tar file directly in base_docker_path: {{ tar_file_status_direct.stat.exists }}"
      tags: [ 'debug' ]

    - name: Find the Docker image folder if .tar not found directly
      ansible.builtin.find:
        paths: "{{ base_docker_path }}"
        file_type: directory
        patterns: "{{ current_image_full_folder_name_pattern }}"
      register: found_docker_folders
      when: not tar_file_status_direct.stat.exists # Szukaj folderu tylko jeśli plik nie został znaleziony bezpośrednio

    - name: Debug found_docker_folders result (if searched)
      ansible.builtin.debug:
        var: found_docker_folders
        msg: "Found docker folders: {{ found_docker_folders.files | map(attribute='path') | list }}"
      tags: [ 'debug' ]
      when: found_docker_folders is defined

    - name: Verify that the .tar file exists within the found folder (if folder found)
      ansible.builtin.stat:
        path: "{{ found_docker_folders.files[0].path }}/{{ current_image_tar_file_name }}"
      register: tar_file_status_in_folder
      when:
        - found_docker_folders is defined
        - found_docker_folders.files is defined
        - found_docker_folders.files | length == 1
        - not tar_file_status_direct.stat.exists # Tylko jeśli plik nie został znaleziony bezpośrednio

    - name: Set final_tar_path if .tar file found in folder
      ansible.builtin.set_fact:
        final_tar_path: "{{ found_docker_folders.files[0].path }}/{{ current_image_tar_file_name }}"
      when:
        - tar_file_status_in_folder is defined
        - tar_file_status_in_folder.stat.exists

    - name: Debug: Final tar path
      ansible.builtin.debug:
        msg: "Final tar path for load: {{ final_tar_path }}"
      tags: [ 'debug' ]

    - name: Fail if no .tar file was found at all
      ansible.builtin.fail:
        msg: "ERROR: No .tar file found for build ID {{ build_id_from_pipeline }} either directly in {{ base_docker_path }} or within a matching folder."
      when: final_tar_path == ""

    # --- KROK 2: Załaduj obraz (.tar) ---
    - name: Load Docker image
      ansible.builtin.shell: |
        {{ docker_cmd }} load -i "{{ final_tar_path }}"
      args:
        # cd do katalogu, w którym znajduje się plik tar
        chdir: "{{ final_tar_path | dirname }}"
      register: load_result

    - name: Display load result
      ansible.builtin.debug:
        msg: "Image load result: {{ load_result.stdout }}"
      tags: [ 'debug' ]

    # --- KROK 3: Uruchom obraz (po załadowaniu) ---
    - name: Run Docker/Podman image with environment variables
      ansible.builtin.shell: |
        "{{ docker_cmd }} run -it --rm \
        -v /app/target:/app/target \
        -e TOKEN_PASSWORD={{ container_env_TOKEN_PASSWORD | quote }} \
        -e GATLING_USERS={{ container_env_GATLING_USERS | quote }} \
        -e SIMULATION_NAME={{ container_env_SIMULATION_NAME | quote }} \
        {{ image_to_run_name | quote }}"
      args:
        warn: false
      register: run_image_result
      # Brak 'when: image_check.stdout | length > 0' ponieważ obraz jest świeżo załadowany
      # Zakładamy, że load_result był sukcesem. Jeśli chcesz sprawdzić, możesz dodać:
      # when: load_result.rc == 0
    - name: Display run image result
      ansible.builtin.debug:
        msg: "Run image result: {{ run_image_result.stdout }}"
      tags: [ 'debug' ]

    # --- KROK 4: Wyczyść środowisko (po uruchomieniu i przekazaniu XML) ---

    - name: Clean up all contents in {{ base_docker_path }} (files and directories)
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop: "{{ lookup('fileglob', base_docker_path + '/*') }}"
      register: cleanup_dir_result
      changed_when: cleanup_dir_result.results | selectattr('changed', 'equalto', true) | list | length > 0
      failed_when: false # Ignoruj błędy, jeśli folder jest pusty lub nie ma nic do usunięcia
      tags: [ 'cleanup' ]

    - name: Display cleanup directory result
      ansible.builtin.debug:
        msg: "Directory cleanup result: {{ cleanup_dir_result }}"
      tags: [ 'debug' ]

    - name: Clean up existing Podman/Docker images (from runtime)
      ansible.builtin.shell: |
        {{ docker_cmd }} rmi $({{ docker_cmd }} images -q) || true
      args:
        warn: false
      changed_when: false
      register: cleanup_images_result
      tags: [ 'cleanup' ]

    - name: Display cleanup images result
      ansible.builtin.debug:
        msg: "Cleanup images result: {{ cleanup_images_result.stdout }}"
      tags: [ 'debug' ]
