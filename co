---
- name: Dynamically run Docker image, fetch report, load new image, and clean up
  hosts: all
  gather_facts: false
  become: true
  become_user: root
  become_method: sudo

  vars:
    base_docker_path: "/app/docker/images"
    build_id_from_pipeline: "{{ build_id_from_pipeline }}"
    image_to_run_name: "{{ image_to_run_name }}"
    container_env_TOKEN_PASSWORD: "{{ TOKEN_PASSWORD }}"
    container_env_GATLING_USERS: "{{ GATLING_USERS }}"
    container_env_SIMULATION_NAME: "{{ SIMULATION_NAME }}"

    docker_cmd: "podman"

    container_junit_report_path: "/app/target/results/TEST-results.xml"
    remote_host_temp_report_path: "/tmp/gatling_junit_report_{{ build_id_from_pipeline }}.xml"
    local_report_path: "{{ lookup('env', 'AGENT_TEMPDIRECTORY') | default('/tmp') }}/junit_reports/{{ build_id_from_pipeline }}"

    image_name_prefix: "skopeoCopy-gatling-test-"
    current_image_full_folder_name_pattern: "{{ image_name_prefix }}{{ build_id_from_pipeline }}*"
    current_image_tar_file_name: "gatling-test-{{ build_id_from_pipeline }}.tar"
    final_tar_path: ""

  tasks:
    - name: Debug docker_cmd
      ansible.builtin.debug:
        msg: "Using command: {{ docker_cmd }}"
      tags: [ 'debug' ]

    - name: Verify current user and groups
      ansible.builtin.shell: |
        echo "Current user: $(whoami)"
        echo "User ID info: $(id)"
        echo "User groups: $(groups)"
      register: user_info
      changed_when: false
      tags: [ 'debug' ]

    - name: Display current user and groups info
      ansible.builtin.debug:
        msg: |
          "Current user: {{ user_info.stdout_lines[0] | default('N/A') }}"
          "User ID info: {{ user_info.stdout_lines[1] | default('N/A') }}"
          "User groups: {{ user_info.stdout_lines[2] | default('N/A') }}"
      tags: [ 'debug' ]

    - name: Ensure /app/target directory exists and has correct permissions for container user
      ansible.builtin.file:
        path: /app/target
        state: directory
        mode: '0775'
        owner: '1001'
        group: '1001'
      become: true
      become_user: root
      tags: [ 'permissions' ]

    - name: Clean up old report files on remote host (if any)
      ansible.builtin.file:
        path: "{{ remote_host_temp_report_path }}"
        state: absent
      tags: [ 'cleanup_reports' ]

    - name: Check if the image to run (from registry) exists locally
      ansible.builtin.shell: "{{ docker_cmd }} images -q {{ image_to_run_name }}"
      register: image_existence_check
      failed_when: false
      changed_when: false

    - name: Fail if image to run (from registry) does not exist locally
      ansible.builtin.fail:
        msg: "ERROR: Docker/Podman image '{{ image_to_run_name }}' not found on host for execution."
      when: image_existence_check.stdout | length == 0

    - name: Run Docker/Podman image in detached mode and get container ID
      ansible.builtin.shell: |
        "{{ docker_cmd }} run -d --rm \
        -v /app/target:/app/target \
        -e TOKEN_PASSWORD={{ container_env_TOKEN_PASSWORD | quote }} \
        -e GATLING_USERS={{ container_env_GATLING_USERS | quote }} \
        -e SIMULATION_NAME={{ container_env_SIMULATION_NAME | quote }} \
        {{ image_to_run_name | quote }}"
      args:
        warn: false
      register: run_container_detached_result
      failed_when: run_container_detached_result.rc != 0

    - name: Debug container ID
      ansible.builtin.debug:
        msg: "Container ID: {{ run_container_detached_result.stdout }}"
      tags: [ 'debug' ]
      when: run_container_detached_result is defined and run_container_detached_result.rc == 0

    - name: Wait for the container to complete its task
      ansible.builtin.shell: |
        "{{ docker_cmd }} wait {{ run_container_detached_result.stdout }}"
      register: wait_container_result
      when:
        - run_container_detached_result is defined
        - run_container_detached_result.rc == 0
      failed_when: "wait_container_result.rc != 0 and wait_container_result.stdout | int != 0" # <-- Zmiana tutaj: całe wyrażenie w cudzysłowach

    - name: Display container's exit code
      ansible.builtin.debug:
        msg: "Container {{ run_container_detached_result.stdout }} exited with code: {{ wait_container_result.stdout }}"
      tags: [ 'debug' ]
      when: wait_container_result is defined

    - name: Copy JUnit report from container to remote host
      ansible.builtin.shell: |
        "{{ docker_cmd }} cp {{ run_container_detached_result.stdout }}:{{ container_junit_report_path }} {{ remote_host_temp_report_path }}"
      args:
        warn: false
      register: cp_report_result
      when:
        - wait_container_result is defined
        - wait_container_result.rc == 0
      failed_when: cp_report_result.rc != 0

    - name: Debug copy report result
      ansible.builtin.debug:
        var: cp_report_result
      tags: [ 'debug' ]
      when: cp_report_result is defined

    - name: Ensure local report directory exists on Ansible controller (Azure DevOps Agent)
      ansible.builtin.file:
        path: "{{ local_report_path }}"
        state: directory
        mode: '0755'
      delegate_to: localhost
      run_once: true
      tags: [ 'junit_report' ]

    - name: Fetch Junit report from remote host to local
      ansible.builtin.fetch:
        src: "{{ remote_host_temp_report_path }}"
        dest: "{{ local_report_path }}"
        flat: yes
      when:
        - cp_report_result is defined
        - cp_report_result.rc == 0
      register: fetch_report_result
      tags: [ 'junit_report' ]

    - name: Display fetch report result
      ansible.builtin.debug:
        var: fetch_report_result
      tags: [ 'debug', 'junit_report' ]
      when: fetch_report_result is defined

    - name: Check if .tar file exists directly in {{ base_docker_path }}
      ansible.builtin.stat:
        path: "{{ base_docker_path }}/{{ current_image_tar_file_name }}"
      register: tar_file_status_direct

    - name: Set final_tar_path if .tar file found directly
      ansible.builtin.set_fact:
        final_tar_path: "{{ base_docker_path }}/{{ current_image_tar_file_name }}"
      when: tar_file_status_direct.stat.exists

    - name: Debug: Tar file found directly?
      ansible.builtin.debug:
        msg: "Tar file directly in base_docker_path: {{ tar_file_status_direct.stat.exists }}"
      tags: [ 'debug' ]

    - name: Find the Docker image folder if .tar not found directly
      ansible.builtin.find:
        paths: "{{ base_docker_path }}"
        file_type: directory
        patterns: "{{ current_image_full_folder_name_pattern }}"
      register: found_docker_folders
      when: not tar_file_status_direct.stat.exists

    - name: Debug found_docker_folders result (if searched)
      ansible.builtin.debug:
        var: found_docker_folders
        msg: "Found docker folders: {{ found_docker_folders.files | map(attribute='path') | list }}"
      tags: [ 'debug' ]
      when: found_docker_folders is defined

    - name: Verify that the .tar file exists within the found folder (if folder found)
      ansible.builtin.stat:
        path: "{{ found_docker_folders.files[0].path }}/{{ current_image_tar_file_name }}"
      register: tar_file_status_in_folder
      when:
        - found_docker_folders is defined
        - found_docker_folders.files is defined
        - found_docker_folders.files | length == 1
        - not tar_file_status_direct.stat.exists

    - name: Set final_tar_path if .tar file found in folder
      ansible.builtin.set_fact:
        final_tar_path: "{{ found_docker_folders.files[0].path }}/{{ current_image_tar_file_name }}"
      # --- POPRAWKA W TYM BLOKU: Liniach 99-102 w Twoim pliku
      when: "tar_file_status_in_folder is defined and tar_file_status_in_folder.stat.exists and final_tar_path == ''" # <-- Zmiana tutaj: całe wyrażenie w cudzysłowach

    - name: Debug: Final tar path for load
      ansible.builtin.debug:
        msg: "Final tar path for load: {{ final_tar_path }}"
      tags: [ 'debug' ]

    - name: Fail if no .tar file was found at all
      ansible.builtin.fail:
        msg: "ERROR: No .tar file '{{ current_image_tar_file_name }}' found for build ID {{ build_id_from_pipeline }} either directly in {{ base_docker_path }} or within a matching folder."
      when: final_tar_path == ""

    - name: Load Docker image from tar file
      ansible.builtin.shell: |
        {{ docker_cmd }} load -i "{{ final_tar_path }}"
      args:
        chdir: "{{ final_tar_path | dirname }}"
      register: load_result
      tags: [ 'load_image' ]

    - name: Display load result
      ansible.builtin.debug:
        msg: "Image load result: {{ load_result.stdout }}"
      tags: [ 'debug', 'load_image' ]

    - name: Clean up existing Podman/Docker images (from runtime)
      ansible.builtin.shell: |
        {{ docker_cmd }} rmi $({{ docker_cmd }} images -q) || true
      args:
        warn: false
      changed_when: false
      register: cleanup_images_result
      tags: [ 'cleanup' ]

    - name: Display cleanup images result
      ansible.builtin.debug:
        msg: "Cleanup images result: {{ cleanup_images_result.stdout }}"
      tags: [ 'debug' ]

    - name: Clean up all contents in {{ base_docker_path }} (files and directories)
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      loop: "{{ lookup('fileglob', base_docker_path + '/*') }}"
      register: cleanup_dir_result
      # --- POPRAWKA W TYM BLOKU: Liniach 207-208 w Twoim pliku
      changed_when: "cleanup_dir_result.results | selectattr('changed', 'equalto', true) | list | length > 0" # <-- Zmiana tutaj: całe wyrażenie w cudzysłowach
      failed_when: false
      tags: [ 'cleanup' ]

    - name: Display cleanup directory result
      ansible.builtin.debug:
        msg: "Directory cleanup result: {{ cleanup_dir_result }}"
      tags: [ 'debug' ]
