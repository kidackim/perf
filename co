---
- name: Dynamically find, clean old, and load Docker image
  hosts: all
  gather_facts: false
  become: true
  become_user: root
  become_method: sudo

  vars:
    base_docker_path: "/app/docker/images"
    build_id_from_pipeline: "{{ build_id_from_pipeline }}"
    image_to_run_name: "{{ image_to_run_name }}"
    container_env_TOKEN_PASSWORD: "{{ TOKEN_PASSWORD }}"
    container_env_GATLING_USERS: "{{ GATLING_USERS }}"
    container_env_SIMULATION_NAME: "{{ SIMULATION_NAME }}"

    current_image_full_folder_name: "skopeoCopy_gatling-test-{{ build_id_from_pipeline }}"
    current_image_tar_file_name: "gatling-test-{{ build_id_from_pipeline }}.tar"

    docker_cmd: "podman"

  tasks:
    - name: Verify current user and groups
      ansible.builtin.shell: |
        echo "Current user: $(whoami)"
        echo "User ID info: $(id)"
        echo "User groups: $(groups)"
      register: user_info
      changed_when: false

    - name: Display current user and groups info
      ansible.builtin.debug:
        msg: |
          "Current user: {{ user_info.stdout_lines[0] | default('N/A') }}"
          "User ID info: {{ user_info.stdout_lines[1] | default('N/A') }}"
          "User groups: {{ user_info.stdout_lines[2] | default('N/A') }}"

    - name: Find the exact Docker image folder name for current build
      ansible.builtin.find:
        paths: "{{ base_docker_path }}"
        file_type: directory
        patterns: "{{ current_image_full_folder_name }}*"
      register: found_docker_folders

    - name: Set fact for found folder path
      ansible.builtin.set_fact:
        full_docker_folder_path: "{{ found_docker_folders.files[0].path }}"
      when: found_docker_folders.files | length > 0

    - name: Fail if no Docker image folder was found for current build
      ansible.builtin.fail:
        msg: "ERROR: Could not find Docker image folder starting with {{ current_image_full_folder_name }} in {{ base_docker_path }}"
      when: full_docker_folder_path is not defined

    - name: Load Docker image from the found folder
      ansible.builtin.shell: |
        {{ docker_cmd }} load -i "{{ full_docker_folder_path }}/{{ current_image_tar_file_name }}"
      args:
        chdir: "{{ full_docker_folder_path }}"
      when: full_docker_folder_path is defined

    - name: Run the newly loaded Docker/Podman image with environment variables
      ansible.builtin.shell: |
        "{{ docker_cmd }} run -it --rm \
        -v /app/target:/app/target \
        -e TOKEN_PASSWORD='{{ container_env_TOKEN_PASSWORD }}' \
        -e GATLING_USERS='{{ container_env_GATLING_USERS }}' \
        -e SIMULATION_NAME='{{ container_env_SIMULATION_NAME }}' \
        {{ image_to_run_name }}"
      args:
        warn: false
      register: run_image_result

    - name: Display run image result
      ansible.builtin.debug:
        msg: "Run image result: {{ run_image_result.stdout }}"

    # NOWY KROK: Pobierz plik raportu JUnit z hosta do agenta Azure DevOps
    - name: Fetch JUnit report from remote host
      ansible.builtin.fetch:
        src: "/app/target/test-results.xml" # Ścieżka do pliku XML na hoście zdalnym
        dest: "./fetched_reports/" # Katalog docelowy na agencie Azure DevOps
        flat: yes # Użyj 'yes' jeśli chcesz, aby plik był bezpośrednio w 'dest' bez podkatalogów hosta
      register: fetch_report_result
      ignore_errors: yes # Kontynuuj nawet jeśli plik nie zostanie znaleziony (np. testy nie wygenerowały raportu)

    - name: Display fetch report result
      ansible.builtin.debug:
        msg: "Fetch report result: {{ fetch_report_result }}"
      when: fetch_report_result is defined

    - name: Clean up existing Podman/Docker images
      ansible.builtin.shell: |
        {{ docker_cmd }} rmi $({{ docker_cmd }} images -q) || true
      args:
        warn: false
      changed_when: false
      register: cleanup_result

    - name: Display cleanup result
      ansible.builtin.debug:
        msg: "Cleanup result: {{ cleanup_result.stdout }}"
