const fs = require('fs');
const path = require('path');
const { XMLBuilder } = require('fast-xml-parser');

const LOG_TYPES = {
  RUN: 'RUN',
  REQUEST: 'REQUEST',
  ERROR: 'ERROR'
};

function parseGatlingSimulationLog(logFilePath) {
  const logContent = fs.readFileSync(logFilePath, 'utf-8');
  const lines = logContent.split('\n').filter(line => line.trim());
  
  const simulationData = {
    name: '',
    startTime: 0,
    endTime: 0,
    requests: {},
    errors: []
  };

  lines.forEach(line => {
    const parts = line.split('\t');
    const type = parts[0];
    
    switch(type) {
      case LOG_TYPES.RUN:
        simulationData.name = parts[1];
        if (parts[3] === 'START') {
          simulationData.startTime = parseInt(parts[2], 10);
        } else if (parts[3] === 'END') {
          simulationData.endTime = parseInt(parts[2], 10);
        }
        break;
        
      case LOG_TYPES.REQUEST:
        const requestId = `${parts[3]}_${parts[4]}_${parts[2]}`;
        
        if (!simulationData.requests[requestId]) {
          simulationData.requests[requestId] = {
            name: parts[4],
            startTime: 0,
            endTime: 0,
            status: 'OK',
            errorMessage: '',
            duration: 0
          };
        }
        
        if (parts[6] === 'START') {
          simulationData.requests[requestId].startTime = parseInt(parts[5], 10);
        } else if (parts[6] === 'END') {
          simulationData.requests[requestId].endTime = parseInt(parts[5], 10);
          simulationData.requests[requestId].status = parts[7] || 'OK';
          simulationData.requests[requestId].errorMessage = parts[8] || '';
          
          if (simulationData.requests[requestId].startTime) {
            simulationData.requests[requestId].duration = 
              (simulationData.requests[requestId].endTime - 
               simulationData.requests[requestId].startTime) / 1000;
          }
        }
        break;
        
      case LOG_TYPES.ERROR:
        simulationData.errors.push({
          timestamp: parseInt(parts[3], 10),
          message: parts[4] || ''
        });
        break;
    }
  });
  
  return simulationData;
}

function convertToJUnitXml(simulationData, thresholds = {}) {
  const defaultThresholds = {
    warning: 2,
    error: 5
  };
  
  const thresholdConfig = { ...defaultThresholds, ...thresholds };
  const testCount = Object.keys(simulationData.requests).length;
  let failureCount = 0;
  let errorCount = simulationData.errors.length;
  
  const totalDuration = simulationData.endTime && simulationData.startTime 
    ? (simulationData.endTime - simulationData.startTime) / 1000 
    : 0;
  
  const testcases = Object.values(simulationData.requests).map(request => {
    const testcase = {
      '@_name': request.name,
      '@_classname': simulationData.name || 'Gatling Simulation',
      '@_time': request.duration.toFixed(3)
    };
    
    if (request.status !== 'OK') {
      failureCount++;
      testcase.failure = {
        '@_message': request.errorMessage || 'Request failed',
        '@_type': 'RequestFailure'
      };
    } else if (request.duration > thresholdConfig.error) {
      errorCount++;
      testcase.error = {
        '@_message': `Response time exceeded error threshold: ${request.duration.toFixed(3)}s`,
        '@_type': 'ResponseTimeExceeded'
      };
    } else if (request.duration > thresholdConfig.warning) {
      failureCount++;
      testcase.failure = {
        '@_message': `Response time exceeded warning threshold: ${request.duration.toFixed(3)}s`,
        '@_type': 'ResponseTimeWarning'
      };
    }
    
    return testcase;
  });

  simulationData.errors.forEach(error => {
    testcases.push({
      '@_name': 'GeneralError',
      '@_classname': simulationData.name || 'Gatling Simulation',
      '@_time': '0',
      'error': {
        '@_message': error.message || 'Unknown error',
        '@_type': 'SimulationError'
      }
    });
  });
  
  const junitData = {
    'testsuites': {
      'testsuite': {
        '@_name': simulationData.name,
        '@_tests': testCount + simulationData.errors.length,
        '@_failures': failureCount,
        '@_errors': errorCount,
        '@_time': totalDuration.toFixed(3),
        'testcase': testcases
      }
    }
  };
  
  return junitData;
}

function generateXmlReport(options) {
  const { simulationLogPath, outputXmlPath, thresholds = {} } = options;

  if (!fs.existsSync(simulationLogPath)) {
    throw new Error(`Simulation log not found: ${simulationLogPath}`);
  }
  
  const outputDir = path.dirname(outputXmlPath);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }
  
  const simulationData = parseGatlingSimulationLog(simulationLogPath);
  const junitData = convertToJUnitXml(simulationData, thresholds);
  
  const builder = new XMLBuilder({
    format: true,
    ignoreAttributes: false,
    processEntities: false
  });
  
  const xmlContent = '<?xml version="1.0" encoding="UTF-8" ?>\n' + builder.build(junitData);
  fs.writeFileSync(outputXmlPath, xmlContent);
  
  return {
    outputPath: outputXmlPath,
    totalTests: junitData.testsuites.testsuite['@_tests'],
    failures: junitData.testsuites.testsuite['@_failures'],
    errors: junitData.testsuites.testsuite['@_errors']
  };
}

function parseCliArgs() {
  const args = process.argv.slice(2);
  const options = {
    simulationLogPath: null,
    outputXmlPath: null,
    thresholds: {
      warning: 2,
      error: 5
    }
  };
  
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    
    if (arg === '--log' || arg === '-l') {
      options.simulationLogPath = args[++i];
    } else if (arg === '--output' || arg === '-o') {
      options.outputXmlPath = args[++i];
    } else if (arg === '--warning-threshold' || arg === '-w') {
      options.thresholds.warning = parseFloat(args[++i]);
    } else if (arg === '--error-threshold' || arg === '-e') {
      options.thresholds.error = parseFloat(args[++i]);
    } else if (arg === '--help') {
      console.log(`
Usage: node script.js [options]

Options:
  --log, -l <path>          Path to simulation.log (required)
  --output, -o <path>       Output XML file path (required)
  --warning-threshold, -w   Warning threshold in seconds (default: 2)
  --error-threshold, -e     Error threshold in seconds (default: 5)
  --help                    Show help
      `);
      process.exit(0);
    }
  }
  
  if (!options.simulationLogPath || !options.outputXmlPath) {
    console.error('Missing required arguments');
    process.exit(1);
  }
  
  return options;
}

if (require.main === module) {
  const options = parseCliArgs();
  generateXmlReport(options);
  console.log(`XML report generated successfully: ${options.outputXmlPath}`);
} else {
  module.exports = { generateXmlReport };
}
